# Enumtrait
A crate for deriving enum based polymorphism.

## Pattern
Often we want to implement traits separately for each variant of a enum.
This is traditionally implemented in two ways:

```rust
trait Bing {
    fn bonk(&self);
}
 
struct Foo();
impl Bing for Foo {
    fn bonk(&self) {}
}
 
struct Bar();
impl Bing for Bar {
    fn bonk(&self) {}
}

fn method_1() {
    // using runtime polymorphism, at cost
    let bings: Vec<Box<dyn Bing>> = vec![Box::new(Foo()), Box::new(Bar())];
    for b in bings {
        b.bonk()
    }
}

fn method_2() {
    // using an enum, at the cost of boilerplate
    enum BingVars {
        Foo(Foo),
        Bar(Bar),
    }
    
    impl Bing for BingVars {
        fn bonk(&self) {
            match self {
                BingVars::Foo(i) => i.bonk(),
                BingVars::Bar(i) => i.bonk(),
            }
        }
    }

    let bings: Vec<BingVars> = vec![BingVars::Foo(Foo()), BingVars::Bar(Bar())];
    for b in bings {
        b.bonk()
    }
}

fn main() {
    method_1();
    method_2();
}
```

The crate removes the boilerplate from `method_2` by generating the enum and the implementation for you.
## Supported Types


## Inter-Macro Communication
Rust macro invocations are independent, and affected by incremental compilation.
- Change in token input means macro needs to be re-expanded
- Macros can be expanded in any order
- Macros are not eagrely expanded (with an exception for some [built in macros](https://github.com/rust-lang/rust/blob/1.54.0/RELEASES.md#language))

This is highly restrictive, solutions to avoid this include:
- Communication through shared data structures or files (cannot share tokens)
- Avoiding communication (verbose)
- not all macros are necessarily invokes, due to incremental compilation

There are proposals for sharing macro state, defining macro order, through a new interface. All have the 
core drawback of requiring language/compiler changes. 

I hope such a feature (e.g. crate local macro persistent state, message passing between macros, etc ) is implemented, but in the meantime, we have this.

*Rust macro invocations are independent.* However, macro definitions are ordered. We can 
use changing macro definitions to force an ordered invocation of other macros.

We do this by building immutable token stores from `macro_rules!` definitions.
```rust
// store(tokens in name)
macro_rules! name {
    ($call:path) => { $call!(tokens); }
}

// read `tokens in name` in my_macro 
name!(my_macro)
```
This gives us a tree of macro invocations, but for utility we need to be able tor ead from multiple token stores.
To do this we apply a macro to the store that defines a new macro to collect tokens from another store.
```rust
// merge tokens from other stores `var_1` and `var_2`

// define a macro that creates a macro definition that accepts more tokens
// NOTE: this is non-compilable pseudocode, cannot macro_rules! inside a macro_rules!, but 
//       we can call a procedural macro that generates a macro_rules! as output 
macro_rules! merge {
    ($var_1:path , $var_2:path , $call:path) => {

        // define a macro to take var_1, and generate a new macro to take var_2
        macro_rules! accumulate_outer {
            ($(t_v1:tt)*) => {

                macro_rules! accumulate_inner {
                    ($(t_v2:tt)*) => {
                        $call ! ( t_v1  t_v2 ) 
                    }
                }
            }
        }

        $var_1 (accumulate_outer); // generate new macro with result
        $var_2 (accumulate_inner); // call $call with both
    }
}

merge!(var_1, var_2, both); // both can then store to a new variable, or do something else
```
With that we can now pass tokens between macros in a [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph).

`enumtrait` passes information between macros using this method.

## Related Work
### [enum_dispatch](https://gitlab.com/antonok/enum_dispatch/)
Attempts to solve the same problem as `enumtrait`, but communicates between macro 
expansions using a shared hashmap.

This technique is [discussed here](https://gitlab.com/antonok/enum_dispatch/#registry-and-linkage).

The abuse of `macro_rules!` used by `enumtrait` is more verbose than `enum_dispatch`'s, however allows 
for identifiers with spans to be communicated between macros, allowing better error messages.

### [eagre](https://github.com/Emoun/eager)
Simulates eagre execution of macros generated by its own `eagre_macro_rules!` macro.

Can be used to 
