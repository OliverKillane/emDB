@online{DBToasterSQLReference,
  author  = {DATA Laboratory at EPFL},
  title   = {The DBToaster SQL Reference},
  year    = 2019,
  url     = {https://dbtoaster.github.io/docs_sql.html},
  urldate = {2024-01-02}
}
@online{TypedGenerationalArenaRepo,
  author  = {Nick Fitzgerald},
  title   = {Generational Arena: A safe arena allocator that allows deletion without suffering from the ABA problem by using generational indices},
  year    = 2023,
  url     = {https://github.com/fitzgen/generational-arena},
  urldate = {2024-01-05}
}

@online{Postgres16Docs,
  author  = {The PostgreSQL Global Development Group},
  title   = {PostgreSQL 16 Documentation},
  year    = 2023,
  url     = {https://www.postgresql.org/docs/current/index.html},
  urldate = {2024-01-05}
}

@online{DuckDBDocs,
  author  = {DuckDB Labs},
  title   = {DuckDB Documentation},
  year    = 2024,
  url     = {https://duckdb.org/docs/},
  urldate = {2024-01-05}
}

@online{SQLiteWebsite,
  author  = {SQLite Consortium},
  title   = {SQLite Website},
  year    = 2024,
  url     = {https://www.sqlite.org/},
  urldate = {2024-01-05}
}

@online{SQLiteVDBEDocs,
  author  = {SQLite Consortium},
  title   = {SQLite VDBE Documentation},
  year    = 2024,
  url     = {https://www.sqlite.org/vdbe.html},
  urldate = {2024-01-05}
}

@online{SQLiteVDBEOpcodeDocs,
  author  = {SQLite Consortium},
  title   = {SQLite VDBE opcode documentation},
  year    = 2024,
  url     = {https://www.sqlite.org/vdbe.html},
  urldate = {2024-01-05}
}

@online{GigaparsecRepo,
  author  = {Jamie Willis},
  title   = {GigaParsec Github Repository},
  year    = 2024,
  url     = {https://github.com/j-mie6/gigaparsec},
  urldate = {2024-01-24}
}

@online{sqlxRepo,
  author  = {LaunchBadge},
  title   = {sqlx Github Repository},
  year    = 2024,
  url     = {https://github.com/launchbadge/sqlx},
  urldate = {2024-01-24}
}

@online{YewRepo,
  author  = {YewStack},
  title   = {Yew Github Respository},
  year    = 2024,
  url     = {https://github.com/yewstack/yew},
  urldate = {2024-01-24}
}

@article{SQLitePaper,
  author     = {Gaffney, Kevin P. and Prammer, Martin and Brasfield, Larry and Hipp, D. Richard and Kennedy, Dan and Patel, Jignesh M.},
  title      = {SQLite: past, present, and future},
  year       = {2022},
  issue_date = {August 2022},
  publisher  = {VLDB Endowment},
  volume     = {15},
  number     = {12},
  issn       = {2150-8097},
  url        = {https://doi.org/10.14778/3554821.3554842},
  doi        = {10.14778/3554821.3554842},
  abstract   = {In the two decades following its initial release, SQLite has become the most widely deployed database engine in existence. Today, SQLite is found in nearly every smartphone, computer, web browser, television, and automobile. Several factors are likely responsible for its ubiquity, including its in-process design, standalone codebase, extensive test suite, and cross-platform file format. While it supports complex analytical queries, SQLite is primarily designed for fast online transaction processing (OLTP), employing row-oriented execution and a B-tree storage format. However, fueled by the rise of edge computing and data science, there is a growing need for efficient in-process online analytical processing (OLAP). DuckDB, a database engine nicknamed "the SQLite for analytics", has recently emerged to meet this demand. While DuckDB has shown strong performance on OLAP benchmarks, it is unclear how SQLite compares. Furthermore, we are aware of no work that attempts to identify root causes for SQLite's performance behavior on OLAP workloads. In this paper, we discuss SQLite in the context of this changing workload landscape. We describe how SQLite evolved from its humble beginnings to the full-featured database engine it is today. We evaluate the performance of modern SQLite on three benchmarks, each representing a different flavor of in-process data management, including transactional, analytical, and blob processing. We delve into analytical data processing on SQLite, identifying key bottlenecks and weighing potential solutions. As a result of our optimizations, SQLite is now up to 4.2X faster on SSB. Finally, we discuss the future of SQLite, envisioning how it will evolve to meet new demands and challenges.},
  journal    = {Proc. VLDB Endow.},
  month      = {aug},
  pages      = {3535–3547},
  numpages   = {13}
}

@article{DBToasterHigherOrderDeltaProcessing,
  author     = {Ahmad, Yanif and Kennedy, Oliver and Koch, Christoph and Nikolic, Milos},
  title      = {DBToaster: higher-order delta processing for dynamic, frequently fresh views},
  year       = {2012},
  issue_date = {June 2012},
  publisher  = {VLDB Endowment},
  volume     = {5},
  number     = {10},
  issn       = {2150-8097},
  url        = {https://doi.org/10.14778/2336664.2336670},
  doi        = {10.14778/2336664.2336670},
  abstract   = {Applications ranging from algorithmic trading to scientific data analysis require realtime analytics based on views over databases that change at very high rates. Such views have to be kept fresh at low maintenance cost and latencies. At the same time, these views have to support classical SQL, rather than window semantics, to enable applications that combine current with aged or historical data.In this paper, we present viewlet transforms, a recursive finite differencing technique applied to queries. The viewlet transform materializes a query and a set of its higher-order deltas as views. These views support each other's incremental maintenance, leading to a reduced overall view maintenance cost. The viewlet transform of a query admits efficient evaluation, the elimination of certain expensive query operations, and aggressive parallelization. We develop viewlet transforms into a workable query execution technique, present a heuristic and cost-based optimization framework, and report on experiments with a prototype dynamic data management system that combines viewlet transforms with an optimizing compilation technique. The system supports tens of thousands of complete view refreshes a second for a wide range of queries.},
  journal    = {Proc. VLDB Endow.},
  month      = {jun},
  pages      = {968–979},
  numpages   = {12}
}

@inproceedings{DuckDBPaper,
  author    = {Raasveldt, Mark and M\"{u}hleisen, Hannes},
  title     = {DuckDB: an Embeddable Analytical Database},
  year      = {2019},
  isbn      = {9781450356435},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3299869.3320212},
  doi       = {10.1145/3299869.3320212},
  abstract  = {The immense popularity of SQLite shows that there is a need for unobtrusive in-process data management solutions. However, there is no such system yet geared towards analytical workloads. We demonstrate DuckDB, a novel data management system designed to execute analytical SQL queries while embedded in another process. In our demonstration, we pit DuckDB against other data management solutions to showcase its performance in the embedded analytics scenario. DuckDB is available as Open Source software under a permissive license.},
  booktitle = {Proceedings of the 2019 International Conference on Management of Data},
  pages     = {1981–1984},
  numpages  = {4},
  location  = {Amsterdam, Netherlands},
  series    = {SIGMOD '19}
}

@inproceedings{MonetDBLitePaper,
  author    = {Raasveldt, Mark},
  title     = {MonetDBLite: An Embedded Analytical Database},
  year      = {2018},
  isbn      = {9781450347037},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3183713.3183722},
  doi       = {10.1145/3183713.3183722},
  booktitle = {Proceedings of the 2018 International Conference on Management of Data},
  pages     = {1837–1838},
  numpages  = {2},
  keywords  = {olap, machine learning, embedded databases},
  location  = {Houston, TX, USA},
  series    = {SIGMOD '18}
}

@unknown{SQLiteJITCompiler,
  author = {Kashuba, Aleksei and Mühleisen, Hannes},
  year   = {2018},
  month  = {08},
  pages  = {},
  url    = {https://arxiv.org/pdf/1808.05448.pdf},
  title  = {Automatic Generation of a Hybrid Query Execution Engine}
}

@inproceedings{HIQUEPaper,
  author    = {Krikellas, Konstantinos and Viglas, Stratis D. and Cintra, Marcelo},
  booktitle = {2010 IEEE 26th International Conference on Data Engineering (ICDE 2010)},
  title     = {Generating code for holistic query evaluation},
  year      = {2010},
  volume    = {},
  number    = {},
  pages     = {613-624},
  keywords  = {Query processing;Engines;Hardware;Prototypes;Database systems;Optimizing compilers;Informatics;Proposals;System performance;Heuristic algorithms},
  doi       = {10.1109/ICDE.2010.5447892}
}

@inproceedings{PAXStorageModel,
  author    = {Ailamaki, Anastassia and DeWitt, David J. and Hill, Mark D. and Skounakis, Marios},
  title     = {Weaving Relations for Cache Performance},
  year      = {2001},
  isbn      = {1558608044},
  publisher = {Morgan Kaufmann Publishers Inc.},
  address   = {San Francisco, CA, USA},
  booktitle = {Proceedings of the 27th International Conference on Very Large Data Bases},
  pages     = {169–180},
  numpages  = {12},
  series    = {VLDB '01}
}

@inproceedings{PracticalTheoryLINQPaper,
  author    = {Cheney, James and Lindley, Sam and Wadler, Philip},
  title     = {A practical theory of language-integrated query},
  year      = {2013},
  isbn      = {9781450323260},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2500365.2500586},
  doi       = {10.1145/2500365.2500586},
  abstract  = {Language-integrated query is receiving renewed attention, in part because of its support through Microsoft's LINQ framework. We present a practical theory of language-integrated query based on quotation and normalisation of quoted terms. Our technique supports join queries, abstraction over values and predicates, composition of queries, dynamic generation of queries, and queries with nested intermediate data. Higher-order features prove useful even for constructing first-order queries. We prove a theorem characterising when a host query is guaranteed to generate a single SQL query. We present experimental results confirming our technique works, even in situations where Microsoft's LINQ framework either fails to produce an SQL query or, in one case, produces an avalanche of SQL queries.},
  booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
  pages     = {403–416},
  numpages  = {14},
  keywords  = {sql, quotation, linq, lambda calculus, f\#, antiquotation},
  location  = {Boston, Massachusetts, USA},
  series    = {ICFP '13}
}

